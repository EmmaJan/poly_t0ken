console.log("üî• Token Starter Plugin Loaded");

figma.showUI(__html__, { width: 700, height: 950, themeColors: true });

// Check if variables exist and notify UI
var existingCollections = figma.variables.getLocalVariableCollections();
if (existingCollections.length > 0) {
  figma.ui.postMessage({ type: "has-variables", value: true });

  // Extraire les tokens existants et les envoyer √† l'UI
  try {
    var existingTokens = extractExistingTokens();
    console.log("Tokens existants extraits:", existingTokens);

    // Compter le nombre total de tokens
    var hasTokens = false;
    for (var cat in existingTokens.tokens) {
      if (existingTokens.tokens.hasOwnProperty(cat) && Object.keys(existingTokens.tokens[cat]).length > 0) {
        hasTokens = true;
        break;
      }
    }

    if (existingTokens && hasTokens) {
      console.log("Envoi des tokens √† l'UI");
      figma.ui.postMessage({
        type: "existing-tokens",
        tokens: existingTokens.tokens,
        library: existingTokens.library
      });
    } else {
      console.log("Aucun token extrait");
    }
  } catch (e) {
    console.error("Erreur lors de l'extraction des tokens existants:", e);
  }
}


// ============================================
// EXTRACT EXISTING TOKENS
// ============================================
function extractExistingTokens() {
  var collections = figma.variables.getLocalVariableCollections();
  console.log("Nombre de collections trouv√©es:", collections.length);

  var tokens = {
    brand: {},
    system: {},
    gray: {},
    spacing: {},
    radius: {},
    typography: {},
    border: {}
  };

  var detectedLibrary = "tailwind"; // Par d√©faut

  for (var i = 0; i < collections.length; i++) {
    var collection = collections[i];
    var collectionName = collection.name;
    console.log("Collection #" + i + ":", collectionName, "(" + collection.variableIds.length + " variables)");

    // D√©terminer la cat√©gorie en matchant les noms exacts cr√©√©s par le plugin
    var category = null;

    if (collectionName === "Brand Colors") {
      category = "brand";
    } else if (collectionName === "System Colors") {
      category = "system";
    } else if (collectionName === "Grayscale") {
      category = "gray";
    } else if (collectionName === "Spacing") {
      category = "spacing";
    } else if (collectionName === "Radius") {
      category = "radius";
    } else if (collectionName === "Typography") {
      category = "typography";
    } else if (collectionName === "Border") {
      category = "border";
    }

    console.log("  ‚Üí Cat√©gorie d√©tect√©e:", category);

    if (!category) {
      console.log("  ‚Üí Collection ignor√©e (ne correspond pas aux collections du plugin)");
      continue;
    }

    // Extraire les variables de cette collection
    var variables = collection.variableIds.map(function (id) {
      return figma.variables.getVariableById(id);
    });

    console.log("  ‚Üí Nombre de variables:", variables.length);

    for (var j = 0; j < variables.length; j++) {
      var variable = variables[j];
      if (!variable) continue;

      var modeId = collection.modes[0].modeId;
      var value = variable.valuesByMode[modeId];

      // Nettoyer le nom de la variable
      var cleanName = variable.name
        .replace(/^(primary|brand|gray|grey|spacing|radius|typo|border)-/i, "")
        .replace(/^primary\//i, "");

      // D√©tecter la librairie bas√©e sur les noms de variables
      if (variable.name.indexOf("/") !== -1) {
        detectedLibrary = "mui";
      } else if (cleanName.match(/^(main|light|dark|contrastText)$/)) {
        detectedLibrary = "mui";
      } else if (cleanName.match(/^(subtle|hover|emphasis)$/)) {
        detectedLibrary = "bootstrap";
      }

      // Convertir la valeur selon le type
      var formattedValue = value;
      if (variable.resolvedType === "COLOR" && typeof value === "object") {
        formattedValue = rgbToHex(value);
      } else if (variable.resolvedType === "FLOAT") {
        formattedValue = value + "px";
      } else if (variable.resolvedType === "STRING") {
        formattedValue = value;
      }

      console.log("    Variable:", variable.name, "‚Üí", cleanName, "=", formattedValue);
      tokens[category][cleanName] = formattedValue;
    }
  }

  console.log("Tokens finaux par cat√©gorie:");
  for (var cat in tokens) {
    console.log("  " + cat + ":", Object.keys(tokens[cat]).length, "tokens");
  }

  return {
    tokens: tokens,
    library: detectedLibrary
  };
}

// ============================================
// COLOR UTILITIES
// ============================================

// ============================================
// COLOR UTILITIES
// ============================================

function hexToRgb(hex) {
  hex = hex.replace("#", "");
  if (hex.length === 3) {
    hex = hex.split("").map(function (x) { return x + x; }).join("");
  }
  var num = parseInt(hex, 16);
  return {
    r: ((num >> 16) & 255) / 255,
    g: ((num >> 8) & 255) / 255,
    b: (num & 255) / 255
  };
}

function rgbToHex(c) {
  console.log("üîç rgbToHex input:", c);

  // V√©rifier si la couleur a une opacit√©/alpha qui pourrait affecter la valeur
  if (c.a !== undefined && c.a < 1) {
    console.log("‚ö†Ô∏è Couleur avec alpha d√©tect√©e:", c.a, "- Conversion ignor√©e car alpha < 1");
    return null; // Retourner null pour les couleurs avec transparence
  }

  var to255 = function (x) {
    // G√©rer les valeurs flottantes qui pourraient √™tre l√©g√®rement hors limites
    var clamped = Math.max(0, Math.min(1, x));
    var v = Math.round(clamped * 255);
    console.log("  Conversion", x, "‚Üí", clamped, "‚Üí", v);
    return v;
  };

  var r = to255(c.r);
  var g = to255(c.g);
  var b = to255(c.b);

  var n = (r << 16) | (g << 8) | b;
  var hex = "#" + n.toString(16).padStart(6, "0").toUpperCase();

  console.log("‚úÖ rgbToHex output:", hex);
  return hex;
}

function hexToHsl(hex) {
  var rgb = hexToRgb(hex);
  var r = rgb.r, g = rgb.g, b = rgb.b;
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
    h /= 6;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return { h: h * 360, s: s * 100, l: l * 100 };
}

function hslToHex(h, s, l) {
  h = h % 360;
  if (h < 0) h += 360;
  s = Math.max(0, Math.min(100, s)) / 100;
  l = Math.max(0, Math.min(100, l)) / 100;

  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(((h / 60) % 2) - 1));
  var m = l - c / 2;
  var r = 0, g = 0, b = 0;

  if (0 <= h && h < 60) { r = c; g = x; b = 0; }
  else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
  else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
  else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
  else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
  else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

  return rgbToHex({ r: r + m, g: g + m, b: b + m });
}

function adjustLightness(hsl, amount) {
  // amount > 0 lightens (towards 100), amount < 0 darkens (towards 0)
  var l = hsl.l;
  var newL = amount > 0 ? l + (100 - l) * amount : l * (1 + amount);
  return hslToHex(hsl.h, hsl.s, newL);
}

function mixColors(color1, color2, weight) {
  var c1 = hexToRgb(color1);
  var c2 = hexToRgb(color2);
  var w = Math.max(0, Math.min(1, weight));
  var w1 = 1 - w;

  return rgbToHex({
    r: c1.r * w1 + c2.r * w,
    g: c1.g * w1 + c2.g * w,
    b: c1.b * w1 + c2.b * w
  });
}

// ============================================
// TOKEN GENERATORS
// ============================================

function generateBrandColors(hex, naming) {
  var hsl = hexToHsl(hex);

  // 1. Tailwind / Chakra / Custom (11 steps: 50-950)
  if (!naming || naming === "tailwind" || naming === "chakra" || naming === "custom") {
    return {
      "50": adjustLightness(hsl, 0.95),
      "100": adjustLightness(hsl, 0.9),
      "200": adjustLightness(hsl, 0.75),
      "300": adjustLightness(hsl, 0.5),
      "400": adjustLightness(hsl, 0.25),
      "500": hex, // Base
      "600": adjustLightness(hsl, -0.1),
      "700": adjustLightness(hsl, -0.25),
      "800": adjustLightness(hsl, -0.4),
      "900": adjustLightness(hsl, -0.6),
      "950": adjustLightness(hsl, -0.8)
    };
  }

  // 2. Ant Design (10 steps: 1-10, Base at 6)
  if (naming === "ant") {
    return {
      "1": adjustLightness(hsl, 0.95),
      "2": adjustLightness(hsl, 0.85),
      "3": adjustLightness(hsl, 0.65),
      "4": adjustLightness(hsl, 0.45),
      "5": adjustLightness(hsl, 0.25),
      "6": hex, // Base
      "7": adjustLightness(hsl, -0.15),
      "8": adjustLightness(hsl, -0.30),
      "9": adjustLightness(hsl, -0.45),
      "10": adjustLightness(hsl, -0.60)
    };
  }

  // 3. Simple Palettes (MUI, Bootstrap)
  var paletteSimple = {
    subtle: adjustLightness(hsl, 0.8),
    light: adjustLightness(hsl, 0.4),
    base: hex,
    hover: adjustLightness(hsl, -0.1),
    dark: adjustLightness(hsl, -0.2)
  };

  if (naming === "mui") {
    return {
      light: paletteSimple.light,
      main: paletteSimple.base,
      dark: paletteSimple.dark,
      contrastText: "#FFFFFF"
    };
  }

  if (naming === "bootstrap") {
    return {
      "primary": paletteSimple.base,
      "primary-subtle": paletteSimple.subtle,
      "primary-hover": paletteSimple.hover,
      "primary-dark": paletteSimple.dark
    };
  }

  return paletteSimple;
}

function generateGrayscale(naming, brandHex) {
  var base = {
    "50": "#F9FAFB",
    "100": "#F3F4F6",
    "200": "#E5E7EB",
    "300": "#D1D5DB",
    "400": "#9CA3AF",
    "500": "#6B7280",
    "600": "#4B5563",
    "700": "#374151",
    "800": "#1F2937",
    "900": "#111827",
    "white": "#FFFFFF",
  };

  var grays = base;

  if (naming === "ant") {
    grays = {
      "1": base["50"],
      "2": base["100"],
      "3": base["200"],
      "4": base["300"],
      "5": base["400"],
      "6": base["500"],
      "7": base["600"],
      "8": base["700"],
      "9": base["800"],
      "10": base["900"]
    };
  }

  // Tint grays with brand color (except white)
  if (brandHex) {
    for (var key in grays) {
      if (grays.hasOwnProperty(key)) {
        var val = grays[key];
        if (val.toLowerCase() !== "#ffffff" && key !== "white") {
          // 4% tint (between 3% and 5%)
          grays[key] = mixColors(val, brandHex, 0.04);
        }
      }
    }
  }

  return grays;
}

function generateSystemColors(naming, brandHex) {
  var baseColors = {
    success: "#10B981",
    warning: "#F59E0B",
    error: "#EF4444",
    info: "#3B82F6"
  };

  var result = {};

  for (var colorName in baseColors) {
    if (!baseColors.hasOwnProperty(colorName)) continue;

    var baseHex = baseColors[colorName];

    // Tint system colors with brand color (12% -> between 10% and 15%)
    if (brandHex) {
      baseHex = mixColors(baseHex, brandHex, 0.12);
    }

    var hsl = hexToHsl(baseHex);

    var light = hslToHex(hsl.h, hsl.s, Math.min(95, hsl.l + 25));
    var dark = hslToHex(hsl.h, hsl.s, Math.max(20, hsl.l - 15));

    if (naming === "mui") {
      result[colorName + "-light"] = light;
      result[colorName + "-main"] = baseHex;
      result[colorName + "-dark"] = dark;
    } else if (naming === "bootstrap") {
      result[colorName] = baseHex;
      result[colorName + "-subtle"] = light;
      result[colorName + "-emphasis"] = dark;
    } else {
      result[colorName + "-light"] = light;
      result[colorName] = baseHex;
      result[colorName + "-dark"] = dark;
    }
  }

  return result;
}

function generateSpacing(naming) {
  if (naming === "mui") {
    return { "1": "8px", "2": "16px", "3": "24px", "4": "32px", "5": "40px" };
  }
  if (naming === "bootstrap") {
    return { "1": "0.25rem", "2": "0.5rem", "3": "1rem", "4": "1.5rem", "5": "3rem" };
  }
  return { "1": "4px", "2": "8px", "3": "12px", "4": "16px", "5": "20px", "6": "24px", "8": "32px" };
}

function generateRadius(naming) {
  if (naming === "mui") {
    return { "xs": "4px", "sm": "8px", "md": "12px", "lg": "16px", "xl": "20px" };
  }
  if (naming === "bootstrap") {
    return { "sm": "0.25rem", "default": "0.375rem", "lg": "0.5rem", "pill": "50rem" };
  }
  return { "sm": "2", "md": "4", "lg": "8", "xl": "12", "2xl": "16", "full": "9999" };
}

/**
 * G√©n√®re les tokens de typographie selon les standards de chaque librairie.
 * Chaque token repr√©sente UNIQUEMENT une taille de police (font-size),
 * sans m√©langer avec font-weight ou autres propri√©t√©s.
 *
 * @param {string} naming - Le nom de la librairie ('tailwind'|'chakra'|'mui'|'bootstrap'|'ant'|'custom')
 * @returns {Object} Objet plat { [cl√©: string]: valeur_font_size }
 */
function generateTypography(naming) {
  // Mode par d√©faut : Tailwind / Chakra / Custom
  // √âchelle de font-size inspir√©e de Tailwind v3, convertie en px
  if (!naming || naming === "tailwind" || naming === "chakra" || naming === "custom") {
    return {
      "text-xs": "12px",    // 0.75rem
      "text-sm": "14px",    // 0.875rem
      "text-base": "16px",  // 1rem
      "text-lg": "18px",    // 1.125rem
      "text-xl": "20px",    // 1.25rem
      "text-2xl": "24px",   // 1.5rem
      "text-3xl": "30px",   // 1.875rem
      "text-4xl": "36px"    // 2.25rem
    };
  }

  // Mode MUI : Cl√©s align√©es sur les variants MUI standards
  // Valeurs converties en px depuis rem
  if (naming === "mui") {
    return {
      "h1": "96px",        // 6rem - Titre principal
      "h2": "60px",        // 3.75rem - Sous-titre principal
      "h3": "48px",        // 3rem - Titre de section
      "h4": "34px",        // 2.125rem - Sous-titre
      "h5": "24px",        // 1.5rem - Petit titre
      "h6": "20px",        // 1.25rem - Tr√®s petit titre
      "subtitle1": "16px", // 1rem - Sous-titre standard
      "subtitle2": "14px", // 0.875rem - Sous-titre secondaire
      "body1": "16px",     // 1rem - Corps de texte principal
      "body2": "14px",     // 0.875rem - Corps de texte secondaire
      "caption": "12px",   // 0.75rem - L√©gende/caption
      "overline": "12px"   // 0.75rem - Texte en majuscules
    };
  }

  // Mode Bootstrap : Cl√©s align√©es avec la typographie Bootstrap
  // Valeurs converties en px depuis rem
  if (naming === "bootstrap") {
    return {
      "h1": "40px",      // 2.5rem - Titre principal
      "h2": "32px",      // 2rem - Titre secondaire
      "h3": "28px",      // 1.75rem - Titre de section
      "h4": "24px",      // 1.5rem - Petit titre
      "h5": "20px",      // 1.25rem - Tr√®s petit titre
      "h6": "16px",      // 1rem - Plus petit titre
      "body": "16px",    // 1rem - Corps de texte
      "lead": "20px",    // 1.25rem - Texte mis en avant
      "small": "14px"    // 0.875rem - Texte secondaire
    };
  }

  // Mode Ant Design : Cl√©s inspir√©es des tokens Ant Design v5
  // Valeurs d√©j√† en px
  if (naming === "ant") {
    return {
      "font-size-sm": "12px",   // Petit texte
      "font-size": "14px",      // Taille par d√©faut
      "font-size-lg": "16px",   // Texte large
      "font-size-xl": "18px"    // Texte extra large
    };
  }

  // Fallback : √©chelle Tailwind par d√©faut convertie en px
  return {
    "text-xs": "12px",
    "text-sm": "14px",
    "text-base": "16px",
    "text-lg": "18px",
    "text-xl": "20px"
  };
}

function generateBorder() {
  return { "1": "1", "2": "2", "4": "4" };
}

// ============================================
// FIGMA SCOPES
// ============================================

var scopesByCategory = {
  brand: ["ALL_FILLS", "STROKE_COLOR", "EFFECT_COLOR"],
  gray: ["ALL_FILLS", "STROKE_COLOR", "EFFECT_COLOR"],
  system: ["ALL_FILLS", "STROKE_COLOR", "EFFECT_COLOR"],
  border: ["STROKE_FLOAT"],
  radius: ["CORNER_RADIUS"],
  spacing: ["GAP", "WIDTH_HEIGHT"],
  typography: ["TEXT_CONTENT"]
};

function applyScopesForCategory(variable, category) {
  if (!variable || !category) return;
  var scopes = scopesByCategory[category];
  if (!scopes || scopes.length === 0) return;
  try {
    variable.scopes = scopes;
  } catch (error) {
    console.warn("[Scopes] Erreur pour", category, error);
  }
}

// ============================================
// IMPORT TOKENS INTO FIGMA
// ============================================

function getOrCreateCollection(name, overwrite) {
  var collections = figma.variables.getLocalVariableCollections();

  // Try to find existing collection
  for (var i = 0; i < collections.length; i++) {
    if (collections[i].name === name) {
      return collections[i]; // Return existing one, do NOT delete it
    }
  }

  // Create new if not found
  return figma.variables.createVariableCollection(name);
}



function createOrUpdateVariable(collection, name, type, value, category, overwrite) {
  // 1. Find existing variable
  var allVariables = figma.variables.getLocalVariables();
  var variable = null;

  for (var i = 0; i < allVariables.length; i++) {
    if (allVariables[i].variableCollectionId === collection.id && allVariables[i].name === name) {
      variable = allVariables[i];
      break;
    }
  }

  // 2. Create if needed
  if (!variable) {
    variable = figma.variables.createVariable(name, collection, type);
  }

  // 3. Update Value
  if (variable) {
    var modeId = collection.modes[0].modeId;
    variable.setValueForMode(modeId, value);
    applyScopesForCategory(variable, category);
  }

  return variable;
}

function importTokensToFigma(tokens, naming, overwrite) {
  // Brand Colors
  if (tokens.brand) {
    var brandCollection = getOrCreateCollection("Brand Colors", overwrite);

    for (var key in tokens.brand) {
      if (!tokens.brand.hasOwnProperty(key)) continue;

      var varName = "";
      if (naming === "mui") varName = "primary/" + key;
      else if (naming === "ant") varName = "primary-" + key;
      else if (naming === "bootstrap") varName = key;
      else varName = "primary-" + key;

      createOrUpdateVariable(brandCollection, varName, "COLOR", hexToRgb(tokens.brand[key]), "brand", overwrite);
    }
  }

  // System Colors
  if (tokens.system) {
    var systemCollection = getOrCreateCollection("System Colors", overwrite);

    for (var sKey in tokens.system) {
      if (!tokens.system.hasOwnProperty(sKey)) continue;
      createOrUpdateVariable(systemCollection, sKey, "COLOR", hexToRgb(tokens.system[sKey]), "system", overwrite);
    }
  }

  // Grayscale
  if (tokens.gray) {
    var grayCollection = getOrCreateCollection("Grayscale", overwrite);

    for (var gKey in tokens.gray) {
      if (!tokens.gray.hasOwnProperty(gKey)) continue;

      var grayName = "";
      if (naming === "mui") grayName = "grey-" + gKey;
      else if (naming === "ant") grayName = "gray-" + gKey;
      else grayName = "gray-" + gKey;

      createOrUpdateVariable(grayCollection, grayName, "COLOR", hexToRgb(tokens.gray[gKey]), "gray", overwrite);
    }
  }

  // Spacing
  if (tokens.spacing) {
    var spacingCollection = getOrCreateCollection("Spacing", overwrite);

    for (var spKey in tokens.spacing) {
      if (!tokens.spacing.hasOwnProperty(spKey)) continue;

      var cleanKey = spKey.replace(/\./g, "-");
      var valueStr = tokens.spacing[spKey];
      var value = parseFloat(valueStr);

      if (valueStr.indexOf("rem") !== -1) {
        value = value * 16;
      }

      createOrUpdateVariable(spacingCollection, "spacing-" + cleanKey, "FLOAT", value, "spacing", overwrite);
    }
  }

  // Radius
  if (tokens.radius) {
    var radiusCollection = getOrCreateCollection("Radius", overwrite);

    for (var rKey in tokens.radius) {
      if (!tokens.radius.hasOwnProperty(rKey)) continue;

      var cleanRKey = rKey.replace(/\./g, "-");
      var rValueStr = tokens.radius[rKey];
      var rValue = parseFloat(rValueStr);

      if (rValueStr.indexOf("rem") !== -1) {
        rValue = rValue * 16;
      }

      createOrUpdateVariable(radiusCollection, "radius-" + cleanRKey, "FLOAT", rValue, "radius", overwrite);
    }
  }

  // Typography
  if (tokens.typography) {
    var typoCollection = getOrCreateCollection("Typography", overwrite);

    for (var tKey in tokens.typography) {
      if (!tokens.typography.hasOwnProperty(tKey)) continue;

      var cleanTKey = tKey.replace(/\./g, "-");
      var typoValueStr = tokens.typography[tKey];
      var typoValue = parseFloat(typoValueStr); // Convertir "16px" ‚Üí 16

      createOrUpdateVariable(typoCollection, "typo-" + cleanTKey, "FLOAT", typoValue, "typography", overwrite);
    }
  }

  // Border
  if (tokens.border) {
    var borderCollection = getOrCreateCollection("Border", overwrite);

    for (var bKey in tokens.border) {
      if (!tokens.border.hasOwnProperty(bKey)) continue;

      var cleanBKey = bKey.replace(/\./g, "-");
      var bValue = parseFloat(tokens.border[bKey]);
      createOrUpdateVariable(borderCollection, "border-" + cleanBKey, "FLOAT", bValue, "border", overwrite);
    }
  }

  figma.notify("‚úÖ All tokens imported successfully!");
}

// ============================================
// MESSAGE HANDLER
// ============================================

var cachedTokens = null;
var lastScanResults = null; // Pour stocker temporairement les r√©sultats du dernier scan

// ============================================
// FRAME VERIFICATION FUNCTIONS
// ============================================

function scanSelection() {
  console.log("üöÄ D√©but de l'analyse de s√©lection...");

  var selection = figma.currentPage.selection;
  console.log("üéØ N≈ìuds s√©lectionn√©s:", selection.length);

  if (selection.length === 0) {
    console.log("‚ùå Aucune s√©lection, arr√™t de l'analyse");
    return [];
  }

  selection.forEach(function(node, index) {
    console.log("  " + (index + 1) + ". " + node.name + " (" + node.type + ")");
  });

  // R√©cup√©rer toutes les variables locales et cr√©er une map invers√©e Valeur -> VariableID
  var valueToVariableMap = createValueToVariableMap();

  var results = [];
  console.log("üîç D√©but du scan r√©cursif...");

  // Parcourir r√©cursivement tous les n≈ìuds s√©lectionn√©s
  selection.forEach(function(node) {
    scanNodeRecursive(node, valueToVariableMap, results);
  });

  // Stocker les r√©sultats pour applyFix
  lastScanResults = results;

  console.log("üèÅ Analyse termin√©e -", results.length, "r√©sultats trouv√©s");

  return results;
}

function createValueToVariableMap() {
  console.log("üîß Construction de la map des variables...");
  var map = new Map();
  var localCollections = figma.variables.getLocalVariableCollections();

  console.log("üìö Collections trouv√©es:", localCollections.length);

  localCollections.forEach(function(collection) {
    console.log("  üìÅ Collection:", collection.name, "(" + collection.variableIds.length + " variables)");

    collection.variableIds.forEach(function(variableId) {
      var variable = figma.variables.getVariableById(variableId);
      if (variable) {
        var value = variable.valuesByMode[variable.defaultModeId];
        console.log("    üîç Variable:", variable.name, "- Valeur brute:", value);

        // Convertir les couleurs RGB en hex pour la comparaison
        if (isColorValue(value)) {
          var hexValue = rgbToHex(value);
          if (hexValue) {
            console.log("      ‚úÖ Conversion hex:", hexValue);
            map.set(hexValue, {
              id: variable.id,
              name: variable.name,
              collectionName: collection.name
            });
          } else {
            console.log("      ‚ùå Conversion hex impossible pour", variable.name);
          }
        }
        // Pour les autres types (nombres), stocker directement
        else if (typeof value === 'number') {
          map.set(value, {
            id: variable.id,
            name: variable.name,
            collectionName: collection.name
          });
        }
      }
    });
  });

  console.log("üìã Map des variables cr√©√©e avec", map.size, "entr√©es");
  return map;
}

function isColorValue(value) {
  return value && typeof value === 'object' && 'r' in value && 'g' in value && 'b' in value;
}

function scanNodeRecursive(node, valueToVariableMap, results) {
  // V√©rifier les propri√©t√©s du n≈ìud actuel
  checkNodeProperties(node, valueToVariableMap, results);

  // Parcourir r√©cursivement les enfants si c'est un conteneur
  if ('children' in node && node.children) {
    node.children.forEach(function(child) {
      scanNodeRecursive(child, valueToVariableMap, results);
    });
  }
}

function checkNodeProperties(node, valueToVariableMap, results) {
  var nodeId = node.id;
  var layerName = node.name;

  console.log("üîç Analyse du n≈ìud:", layerName, "(ID:", nodeId + ")");

  // Afficher toutes les cl√©s disponibles dans la map des variables
  console.log("üìã Couleurs disponibles dans valueToVariableMap:", Array.from(valueToVariableMap.keys()));

  // V√©rifier les fills (couleurs de fond)
  if (node.fills && Array.isArray(node.fills)) {
    console.log("üé® Fills trouv√©s:", node.fills.length);
    node.fills.forEach(function(fill, index) {
      console.log("  Fill #" + index + ":", fill);

      if (fill.type === 'SOLID') {
        console.log("    ‚úÖ Fill solide d√©tect√©");

        // V√©rifier si d√©j√† li√© √† une variable
        var isBound = node.boundVariables && node.boundVariables.fills && node.boundVariables.fills[index];
        console.log("    üîó D√©j√† li√© √† une variable:", isBound);

        if (!isBound) {
          console.log("    üéØ Couleur brute RGB:", fill.color);
          var hexValue = rgbToHex(fill.color);

          if (hexValue) {
            console.log("    üîç Recherche de la variable pour:", hexValue);
            var suggestedVar = valueToVariableMap.get(hexValue);

            if (suggestedVar) {
              console.log("    ‚úÖ Variable trouv√©e:", suggestedVar.name, "(ID:", suggestedVar.id + ")");
              results.push({
                nodeId: nodeId,
                layerName: layerName,
                property: "Fill",
                value: hexValue,
                suggestedVariableId: suggestedVar.id,
                suggestedVariableName: suggestedVar.name
              });
            } else {
              console.log("    ‚ùå Aucune variable trouv√©e pour cette couleur");
            }
          } else {
            console.log("    ‚ö†Ô∏è Conversion hex impossible (couleur transparente?)");
          }
        } else {
          console.log("    ‚è≠Ô∏è Fill d√©j√† li√©, ignor√©");
        }
      } else {
        console.log("    ‚è≠Ô∏è Fill non-solide ignor√© (type:", fill.type + ")");
      }
    });
  } else {
    console.log("‚ùå Aucun fill trouv√©");
  }

  // V√©rifier les strokes (couleurs de contour)
  if (node.strokes && Array.isArray(node.strokes)) {
    console.log("üñºÔ∏è Strokes trouv√©s:", node.strokes.length);
    node.strokes.forEach(function(stroke, index) {
      console.log("  Stroke #" + index + ":", stroke);

      if (stroke.type === 'SOLID') {
        console.log("    ‚úÖ Stroke solide d√©tect√©");

        // V√©rifier si d√©j√† li√© √† une variable
        var isBound = node.boundVariables && node.boundVariables.strokes && node.boundVariables.strokes[index];
        console.log("    üîó D√©j√† li√© √† une variable:", isBound);

        if (!isBound) {
          console.log("    üéØ Couleur brute RGB:", stroke.color);
          var hexValue = rgbToHex(stroke.color);

          if (hexValue) {
            console.log("    üîç Recherche de la variable pour:", hexValue);
            var suggestedVar = valueToVariableMap.get(hexValue);

            if (suggestedVar) {
              console.log("    ‚úÖ Variable trouv√©e:", suggestedVar.name, "(ID:", suggestedVar.id + ")");
              results.push({
                nodeId: nodeId,
                layerName: layerName,
                property: "Stroke",
                value: hexValue,
                suggestedVariableId: suggestedVar.id,
                suggestedVariableName: suggestedVar.name
              });
            } else {
              console.log("    ‚ùå Aucune variable trouv√©e pour cette couleur");
            }
          } else {
            console.log("    ‚ö†Ô∏è Conversion hex impossible (couleur transparente?)");
          }
        } else {
          console.log("    ‚è≠Ô∏è Stroke d√©j√† li√©, ignor√©");
        }
      } else {
        console.log("    ‚è≠Ô∏è Stroke non-solide ignor√© (type:", stroke.type + ")");
      }
    });
  } else {
    console.log("‚ùå Aucun stroke trouv√©");
  }

  console.log("üèÅ Fin de l'analyse pour", layerName);
}

  // V√©rifier cornerRadius
  if (typeof node.cornerRadius === 'number' && node.cornerRadius !== undefined) {
    if (!node.boundVariables || !node.boundVariables.cornerRadius) {
      var suggestedVar = valueToVariableMap.get(node.cornerRadius);
      if (suggestedVar) {
        results.push({
          nodeId: nodeId,
          layerName: layerName,
          property: "Corner Radius",
          value: node.cornerRadius + "px",
          suggestedVariableId: suggestedVar.id,
          suggestedVariableName: suggestedVar.name
        });
      }
    }
  }

  // V√©rifier itemSpacing (gap pour AutoLayout)
  if (typeof node.itemSpacing === 'number' && node.itemSpacing !== undefined) {
    if (!node.boundVariables || !node.boundVariables.itemSpacing) {
      var suggestedVar = valueToVariableMap.get(node.itemSpacing);
      if (suggestedVar) {
        results.push({
          nodeId: nodeId,
          layerName: layerName,
          property: "Item Spacing",
          value: node.itemSpacing + "px",
          suggestedVariableId: suggestedVar.id,
          suggestedVariableName: suggestedVar.name
        });
      }
    }
  }
}

function applyFix(resultIndex) {
  if (!lastScanResults || resultIndex >= lastScanResults.length) {
    throw new Error("R√©sultat non trouv√©");
  }

  var result = lastScanResults[resultIndex];
  var node = figma.getNodeById(result.nodeId);

  if (!node) {
    throw new Error("N≈ìud non trouv√©");
  }

  var variable = figma.variables.getVariableById(result.suggestedVariableId);
  if (!variable) {
    throw new Error("Variable non trouv√©e");
  }

  // Appliquer selon la propri√©t√©
  if (result.property === "Fill") {
    // Pour les fills, il faut g√©rer le tableau de paints
    if (node.fills && Array.isArray(node.fills)) {
      var newFills = node.fills.map(function(fill, index) {
        if (fill.type === 'SOLID' && !(node.boundVariables && node.boundVariables.fills && node.boundVariables.fills[index])) {
          // Cr√©er un nouveau fill li√© √† la variable
          return {
            type: 'SOLID',
            color: fill.color,
            boundVariables: {
              color: variable
            }
          };
        }
        return fill;
      });
      node.fills = newFills;
    }
  }
  else if (result.property === "Stroke") {
    // Pour les strokes, m√™me logique
    if (node.strokes && Array.isArray(node.strokes)) {
      var newStrokes = node.strokes.map(function(stroke, index) {
        if (stroke.type === 'SOLID' && !(node.boundVariables && node.boundVariables.strokes && node.boundVariables.strokes[index])) {
          return {
            type: 'SOLID',
            color: stroke.color,
            boundVariables: {
              color: variable
            }
          };
        }
        return stroke;
      });
      node.strokes = newStrokes;
    }
  }
  else if (result.property === "Corner Radius") {
    node.setBoundVariable('cornerRadius', variable);
  }
  else if (result.property === "Item Spacing") {
    node.setBoundVariable('itemSpacing', variable);
  }

  // Re-scanner automatiquement apr√®s application
  setTimeout(function() {
    var newResults = scanSelection();
    figma.ui.postMessage({
      type: "scan-results",
      results: newResults
    });
  }, 100);
}

// ============================================
// SELECTION CHANGE LISTENER
// ============================================

// Fonction r√©utilisable pour v√©rifier la s√©lection
function checkAndNotifySelection() {
  var selection = figma.currentPage.selection;

  // On accepte Frame, Group, Component, Instance ou Section
  var hasValidSelection = selection.length > 0 && selection.some(function(node) {
    return node.type === "FRAME" ||
           node.type === "GROUP" ||
           node.type === "COMPONENT" ||
           node.type === "INSTANCE" ||
           node.type === "SECTION";
  });

  // Envoyer le message √† l'UI
  figma.ui.postMessage({
    type: "selection-checked",
    hasSelection: hasValidSelection
  });
}

// 1. √âcouter les changements de s√©lection en temps r√©el
figma.on("selectionchange", function() {
  checkAndNotifySelection();
});

// 2. V√©rifier aussi au lancement (si l'utilisateur a d√©j√† s√©lectionn√© un truc avant d'ouvrir)
checkAndNotifySelection();

figma.ui.onmessage = function (msg) {
  if (msg.type === "generate") {
    var naming = msg.naming || "custom";

    var tokens = {
      brand: generateBrandColors(msg.color, naming),
      system: generateSystemColors(naming, msg.color),
      gray: generateGrayscale(naming, msg.color),
      spacing: generateSpacing(naming),
      radius: generateRadius(naming),
      typography: generateTypography(naming),
      border: generateBorder()
    };

    cachedTokens = tokens;

    figma.ui.postMessage({
      type: "tokens-generated",
      tokens: tokens
    });
  }

  if (msg.type === "import") {
    var tokensToImport = msg.tokens || cachedTokens;
    if (tokensToImport) {
      importTokensToFigma(tokensToImport, msg.naming || "custom", msg.overwrite);
    } else {
      figma.notify("‚ö†Ô∏è Generate tokens first!");
    }
  }

  // ‚≠ê Nouveau : import direct depuis un fichier JSON / CSS
  if (msg.type === "import-from-file") {
    var namingFromFile = msg.naming || "custom";
    var tokensFromFile = msg.tokens;

    if (!tokensFromFile) {
      figma.notify("‚ö†Ô∏è Aucun token re√ßu depuis le fichier");
      return;
    }

    try {
      importTokensToFigma(tokensFromFile, namingFromFile, false);
      figma.notify("‚úÖ Tokens import√©s depuis le fichier");
    } catch (e) {
      console.error(e);
      figma.notify("‚ùå Erreur lors de l'import depuis le fichier");
    }
  }

  // Gestionnaire pour le redimensionnement de la fen√™tre
  if (msg.type === "resize") {
    // Contraintes de taille pour une bonne UX
    var MIN_WIDTH = 400;
    var MAX_WIDTH = 1600;
    var MIN_HEIGHT = 500;
    var MAX_HEIGHT = 1400;

    var width = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, msg.width || 700));
    var height = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, msg.height || 950));

    try {
      figma.ui.resize(width, height);
    } catch (error) {
      console.warn("Erreur lors du redimensionnement:", error);
    }
  }

  // Gestionnaire pour l'analyse de frame
  if (msg.type === "scan-frame") {
    try {
      var results = scanSelection();
      figma.ui.postMessage({
        type: "scan-results",
        results: results
      });
    } catch (e) {
      console.error("Erreur lors de l'analyse:", e);
      figma.notify("‚ùå Erreur lors de l'analyse de la frame");
    }
  }

  // Gestionnaire pour appliquer un fix
  if (msg.type === "apply-fix") {
    try {
      applyFix(msg.resultIndex);
      figma.ui.postMessage({
        type: "fix-applied"
      });
    } catch (e) {
      console.error("Erreur lors de l'application du fix:", e);
      figma.notify("‚ùå Erreur lors de l'application du fix");
    }
  }

  // Gestionnaire pour v√©rifier la s√©lection (appel manuel depuis l'UI)
  if (msg.type === "check-selection") {
    checkAndNotifySelection();
  }
};
