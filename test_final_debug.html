<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Final - Bouton Corriger Onglet Auto</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .card { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
        .auto-fixable { border-color: green; background-color: #f0fff0; }
        .manual-required { border-color: orange; background-color: #fffaf0; }
        .hidden { display: none; opacity: 0.5; }
        .tab { padding: 10px; margin: 5px; cursor: pointer; background-color: #eee; display: inline-block; }
        .tab.active { background-color: #007acc; color: white; font-weight: bold; }
        button { padding: 10px; margin: 10px; cursor: pointer; }
        .log { border: 1px solid #ddd; padding: 10px; margin-top: 20px; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        .log-entry { margin: 2px 0; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <h1>Test Final - Bouton "Corriger" sur Onglet Auto</h1>

    <div>
        <div class="tab active" data-filter="auto">Auto <span id="autoCount">0</span></div>
        <div class="tab" data-filter="manual">Manuel <span id="manualCount">0</span></div>
    </div>

    <button id="applyAllAutoBtn">‚ú® Appliquer les corrections</button>

    <div id="cards">
        <!-- Cartes auto-fixables -->
        <div class="card auto-fixable" data-indices="[0]">
            <strong>Auto-fixable 1:</strong> Variable couleur principale ‚Üí #FF0000
        </div>
        <div class="card auto-fixable" data-indices="[1]">
            <strong>Auto-fixable 2:</strong> Variable espacement ‚Üí 16px
        </div>

        <!-- Cartes manuelles -->
        <div class="card manual-required" data-indices="[2]">
            <strong>Manuel 1:</strong> Conflit entre rouge primaire et rouge secondaire
            <select class="manual-select" data-indices="[2]">
                <option value="">Choisir une variable...</option>
                <option value="red-primary">Rouge primaire</option>
                <option value="red-secondary">Rouge secondaire</option>
            </select>
        </div>
        <div class="card manual-required" data-indices="[3]">
            <strong>Manuel 2:</strong> Espacement conflictuel
            <select class="manual-select" data-indices="[3]">
                <option value="">Choisir une variable...</option>
                <option value="spacing-sm">Petit espacement</option>
                <option value="spacing-md">Moyen espacement</option>
            </select>
        </div>
    </div>

    <div class="log" id="log"></div>

    <script>
        var currentFilter = 'auto';
        var ignoredResultIndices = [];

        // Simulation des fonctions du plugin
        function showNotification(message, type) {
            log(`üîî NOTIFICATION [${type.toUpperCase()}]: ${message}`);
        }

        function applyGroupFix(indices, variableId) {
            log(`üîß APPLYING CORRECTION: indices=${JSON.stringify(indices)}, variableId="${variableId}"`);

            // Simuler l'application r√©ussie
            setTimeout(() => {
                handleSingleFixApplied(1, null, indices[0]);
            }, 500);
        }

        function handleSingleFixApplied(appliedCount, error, index) {
            if (error) {
                log(`‚ùå ERREUR lors de la correction de l'index ${index}: ${error}`);
                showNotification('Erreur lors de l\'application', 'error');
                return;
            }

            if (appliedCount > 0) {
                log(`‚úÖ CORRECTION R√âUSSIE pour l'index ${index}`);

                // Masquer la carte
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    const cardIndices = JSON.parse(card.getAttribute('data-indices') || '[]');
                    if (cardIndices.includes(index)) {
                        card.style.display = 'none';
                        log(`üëÅÔ∏è CARTE MASQU√âE: ${card.querySelector('strong').textContent}`);
                    }
                });

                updateDynamicTabCounts();
            }
        }

        // Fonction de logging
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        // Mise √† jour des compteurs d'onglets
        function updateDynamicTabCounts() {
            const cards = document.querySelectorAll('.card');
            let autoCount = 0;
            let manualCount = 0;

            cards.forEach(card => {
                if (card.style.display !== 'none') {
                    if (card.classList.contains('auto-fixable')) autoCount++;
                    if (card.classList.contains('manual-required')) manualCount++;
                }
            });

            document.getElementById('autoCount').textContent = autoCount;
            document.getElementById('manualCount').textContent = manualCount;

            log(`üìä COUNTS UPDATED: Auto=${autoCount}, Manual=${manualCount}`);
        }

        // Gestion des onglets
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                currentFilter = this.getAttribute('data-filter');

                applyFilter(currentFilter);
                updateDynamicTabCounts();
                log(`üîÑ SWITCHED TO TAB: ${currentFilter}`);
            });
        });

        // Fonction applyFilter
        function applyFilter(filterType) {
            const cards = document.querySelectorAll('.card');

            cards.forEach(card => {
                let isVisible = false;

                if (filterType === 'auto') {
                    isVisible = card.classList.contains('auto-fixable');
                } else if (filterType === 'manual') {
                    isVisible = card.classList.contains('manual-required');
                }

                card.style.display = isVisible ? 'block' : 'none';
            });
        }

        // Fonction applyAllAutoFixes MODIFI√âE
        function applyAllAutoFixes() {
            log('üöÄ === applyAllAutoFixes called ===');

            // V√©rifier que nous sommes sur l'onglet "Auto"
            if (currentFilter !== 'auto') {
                log(`üö´ IGNORED - onglet actif: ${currentFilter}`);
                showNotification('Cette action n\'est disponible que sur l\'onglet "Auto"', 'warning');
                return;
            }

            // R√©cup√©rer TOUTES les cartes auto-fixables visibles dans l'onglet actif
            var autoCards = Array.from(document.querySelectorAll('.card.auto-fixable'))
                .filter(card => card.style.display !== 'none');

            log(`üìã Found ${autoCards.length} auto-fixable cards to process`);

            if (autoCards.length === 0) {
                log('üì≠ No auto-fixable cards to process');
                showNotification('Aucune correction automatique disponible', 'info');
                return;
            }

            // D√©sactiver le bouton
            const applyBtn = document.getElementById('applyAllAutoBtn');
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.textContent = 'Correction en cours...';
            }

            var fixesApplied = 0;
            var processedCards = 0;

            // Fonction pour traiter chaque carte s√©quentiellement
            function processNextCard() {
                if (processedCards >= autoCards.length) {
                    log('üèÅ All auto cards processed, finishing');

                    // R√©activer le bouton
                    if (applyBtn) {
                        applyBtn.disabled = false;
                        applyBtn.textContent = '‚ú® Appliquer les corrections';
                    }

                    if (fixesApplied > 0) {
                        showNotification(`${fixesApplied} correction${fixesApplied > 1 ? 's' : ''} appliqu√©e${fixesApplied > 1 ? 's' : ''} !`, 'success');
                    }

                    return;
                }

                var card = autoCards[processedCards];
                log(`‚öôÔ∏è Processing card ${processedCards + 1}/${autoCards.length}: ${card.querySelector('strong').textContent}`);

                // Simuler l'extraction des informations de correction
                const indices = JSON.parse(card.getAttribute('data-indices'));
                const variableId = 'auto-variable-' + indices[0]; // Simulation

                // Appliquer la correction
                applyGroupFix(indices, variableId);
                fixesApplied++;

                // Passer √† la suivante apr√®s un d√©lai
                setTimeout(() => {
                    processedCards++;
                    processNextCard();
                }, 600);
            }

            // D√©marrer le traitement
            processNextCard();
        }

        // Attacher les √©v√©nements
        document.getElementById('applyAllAutoBtn').addEventListener('click', applyAllAutoFixes);

        // Initialisation
        applyFilter('auto');
        updateDynamicTabCounts();
        log('üéØ Page initialized - currentFilter: auto');
        log('üìù Test: Cliquez sur "Appliquer les corrections" sur l\'onglet Auto');
        log('üìù Test: Changez d\'onglet et recliquez pour voir la protection');
    </script>
</body>
</html>