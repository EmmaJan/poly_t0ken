<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Final - Correction du Bouton G√©n√©rer les Tokens</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .step { margin: 20px 0; padding: 15px; border-left: 4px solid #007acc; background: #f0f8ff; }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .result { font-family: monospace; background: #f9f9f9; padding: 10px; margin: 10px 0; border-radius: 4px; }
        button { padding: 10px 20px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #005aa3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Test Final - Bouton "G√©n√©rer les Tokens"</h1>

        <div class="step">
            <h3>üìã Corrections appliqu√©es</h3>
            <ul>
                <li><span class="success">‚úì</span> Correction de <code>hexToRgb</code> qui normalisait incorrectement les valeurs RGB</li>
                <li><span class="success">‚úì</span> Correction de la logique de fallback pour <code>msg.naming</code> (cha√Æne vide ‚Üí "custom")</li>
                <li><span class="success">‚úì</span> Ajout du gestionnaire du message "tokens-generated" dans l'UI</li>
                <li><span class="success">‚úì</span> D√©finition d'une valeur par d√©faut "custom" pour <code>currentNaming</code></li>
                <li><span class="success">‚úì</span> Ajout de logs d√©taill√©s pour le d√©bogage</li>
            </ul>
        </div>

        <div class="step">
            <h3>üîç Test des fonctions corrig√©es</h3>
            <button id="testColors">Tester les conversions de couleur</button>
            <button id="testTokens">Tester la g√©n√©ration de tokens</button>
            <div id="testResults"></div>
        </div>

        <div class="step">
            <h3>üéØ Simulation compl√®te du bouton</h3>
            <p>Cette simulation reproduit exactement le comportement du bouton "G√©n√©rer les Tokens".</p>

            <label>Couleur: <input type="color" id="colorInput" value="#007ACC"></label><br><br>

            <label>Biblioth√®que:
                <select id="namingInput">
                    <option value="custom">Custom</option>
                    <option value="shadcn">ShadCN</option>
                    <option value="antd">Ant Design</option>
                </select>
            </label><br><br>

            <button id="simulateGenerate">üöÄ G√©n√©rer les Tokens (Simulation)</button>

            <div id="simulationResults"></div>
        </div>

        <div id="logs"></div>
    </div>

    <!-- Charger le code du plugin -->
    <script src="code.js"></script>

    <script>
        const testResults = document.getElementById('testResults');
        const simulationResults = document.getElementById('simulationResults');
        const logs = document.getElementById('logs');

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.className = type;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            console.log(`[${type}] ${message}`);
        }

        // Test des conversions de couleur
        document.getElementById('testColors').addEventListener('click', () => {
            testResults.innerHTML = '<h4>Test des conversions de couleur</h4>';

            try {
                // Test hexToRgb corrig√©
                const rgb = hexToRgb('#FF0000');
                if (rgb.r === 255 && rgb.g === 0 && rgb.b === 0) {
                    testResults.innerHTML += '<div class="success">‚úì hexToRgb("#FF0000") fonctionne</div>';
                } else {
                    throw new Error(`hexToRgb retourne ${JSON.stringify(rgb)} au lieu de {r:255,g:0,b:0}`);
                }

                // Test hexToHsl
                const hsl = hexToHsl('#FF0000');
                if (Math.abs(hsl.h - 0) < 5 && Math.abs(hsl.s - 100) < 5 && Math.abs(hsl.l - 50) < 5) {
                    testResults.innerHTML += '<div class="success">‚úì hexToHsl("#FF0000") fonctionne</div>';
                } else {
                    throw new Error(`hexToHsl retourne ${JSON.stringify(hsl)}`);
                }

                // Test round-trip
                const original = '#007ACC';
                const hsl2 = hexToHsl(original);
                const back = hslToHex(hsl2.h, hsl2.s, hsl2.l);
                testResults.innerHTML += `<div class="info">Round-trip: ${original} ‚Üí ${back.toUpperCase()}</div>`;

                testResults.innerHTML += '<div class="success">üéâ Toutes les conversions de couleur fonctionnent !</div>';

            } catch (error) {
                testResults.innerHTML += `<div class="error">‚ùå Erreur: ${error.message}</div>`;
            }
        });

        // Test de g√©n√©ration de tokens
        document.getElementById('testTokens').addEventListener('click', () => {
            testResults.innerHTML += '<h4>Test de g√©n√©ration de tokens</h4>';

            try {
                const tokens = generateBrandColors('#007ACC', 'custom');
                if (tokens && tokens.base && tokens.light && tokens.dark) {
                    testResults.innerHTML += '<div class="success">‚úì generateBrandColors fonctionne</div>';
                    testResults.innerHTML += `<div class="result">${JSON.stringify(tokens, null, 2)}</div>`;
                } else {
                    throw new Error('generateBrandColors ne retourne pas les bonnes propri√©t√©s');
                }

            } catch (error) {
                testResults.innerHTML += `<div class="error">‚ùå Erreur g√©n√©ration tokens: ${error.message}</div>`;
            }
        });

        // Simulation compl√®te
        document.getElementById('simulateGenerate').addEventListener('click', () => {
            const color = document.getElementById('colorInput').value;
            const naming = document.getElementById('namingInput').value;

            simulationResults.innerHTML = '<h4>Simulation du bouton "G√©n√©rer les Tokens"</h4>';

            log(`üñ±Ô∏è Bouton cliqu√© avec color=${color}, naming="${naming}"`);

            // Simuler l'envoi du message au plugin
            const message = {
                pluginMessage: {
                    type: "generate",
                    color: color,
                    naming: naming
                }
            };

            log(`üì§ Message envoy√©: ${JSON.stringify(message)}`);

            // Simuler la r√©ception par le plugin (avec notre logique corrig√©e)
            setTimeout(() => {
                log('üîÑ Plugin traite le message...');

                try {
                    // Appliquer la logique corrig√©e
                    const resolvedNaming = message.pluginMessage.naming && message.pluginMessage.naming.trim() !== ""
                        ? message.pluginMessage.naming
                        : "custom";

                    log(`üìù Naming r√©solu: "${message.pluginMessage.naming}" ‚Üí "${resolvedNaming}"`);

                    // G√©n√©rer les tokens
                    const tokens = {
                        brand: generateBrandColors(message.pluginMessage.color, resolvedNaming),
                        system: generateSystemColors(resolvedNaming),
                        gray: generateGrayscale(resolvedNaming),
                        spacing: generateSpacing(resolvedNaming),
                        radius: generateRadius(resolvedNaming),
                        typography: generateTypography(resolvedNaming),
                        border: generateBorder()
                    };

                    log(`‚úÖ Tokens g√©n√©r√©s: ${Object.keys(tokens).length} cat√©gories`);

                    // Simuler l'envoi √† l'UI
                    log('üì§ Envoi du message tokens-generated √† l\'UI');

                    // Simuler la r√©ception par l'UI
                    setTimeout(() => {
                        log('üì• UI re√ßoit tokens-generated');
                        simulationResults.innerHTML += '<div class="success">üéâ Tokens g√©n√©r√©s avec succ√®s !</div>';
                        simulationResults.innerHTML += '<div class="result">Tokens cr√©√©s pour les cat√©gories: ' + Object.keys(tokens).join(', ') + '</div>';

                        // Afficher quelques exemples
                        const brandKeys = Object.keys(tokens.brand);
                        if (brandKeys.length > 0) {
                            simulationResults.innerHTML += `<div class="result">Exemples brand tokens: ${brandKeys.slice(0, 3).join(', ')}</div>`;
                        }
                    }, 100);

                } catch (error) {
                    log(`‚ùå Erreur: ${error.message}`, 'error');
                    simulationResults.innerHTML += `<div class="error">‚ùå Erreur lors de la g√©n√©ration: ${error.message}</div>`;
                }
            }, 200);
        });

        // Auto-test au chargement
        setTimeout(() => {
            log('üöÄ D√©marrage des tests automatiques...');
            document.getElementById('testColors').click();

            setTimeout(() => {
                document.getElementById('simulateGenerate').click();
            }, 1000);
        }, 500);
    </script>
</body>
</html>